
Data File Formats
=================

The folders `raw` `data` contains captured bit rate success traces.

Files `raw/*.trace`
--------------------

These are directly captured from the kernel, with newer versions; they have one record per line, such as:

    Last(2630707680) took 5135412 ns / 20 tries with rate 22 at 26000(24800) kbps [1]
    
There are six fields here:

 + A unique identifier based on the start time for transmission
 + The time it took to transmit the packet, in nanoseconds
 + The number of tries it took to transmit it (including the successful transmission), up to 20.
 + The identifier for the rate
 + The rate's kilobits per second
 + The rate's kilobits of payload per second; this elides the overhead of FEC and physical-layer headers.
 + The line's index in the internal kernel buffer; if this ever surpasses about 30, we might be missing records.
      
It is suggested that the `data2/munge.py` script be used to transform these files before use.

There are also sanity-check lines like

    0:46 1:323 2:5 3:9 4:13 5:76 6:169 7:739 8:228 9:100 10:290 11:3 
 
These are ignored by the munger, but if any numbers get appreciably big (compared to the range of an unsigned int), there may be problems.


Files `raw/raw_old/*.trace`
-------------------

These are directly captured from the kernel; they have one record per line, such as:

    Last(2630707680) took 5135412 ns / 20 tries with rate 22 at 26000(24800) kbps [1]
    
There are six fields here:

 + A unique identifier based on the start time for transmission
 + The time it took to transmit the packet, in nanoseconds
 + The number of tries it took to transmit it (including the successful transmission), up to 20.
 + The identifier for the rate
 + The rate's kilobits per second
 + The rate's kilobits of payload per second; this elides the overhead of FEC and physical-layer headers.
 
The last line of each file may be incomplete.  The records may also be muddled with concurrency errors and partial reads.  It is suggested that the `data/numpyify.py` script be used to transform these files before use.


Files `data/*.dat`
-------------------

These files are converted from the `raw2/*.trace` files into Python trace dumps.  They're best read with:

    eval(open(file_name, "rt").read())

Each file contains a tuple, with three entries: the start time of the first packet, the data arrays, and the start time of the last packet.  The data array has a list of tuples for each rate; thus, it is a list of 12 lists.

Each list of tuples has tuples of three elements: the send time, whether or not the packet succeeded, and how long the transmission took.  The tuples are ordered by send time.


Files `data/data_old/*.npy`
------------------

These files are converted from the `raw/*.trace` files into Numpy array dumps.  They're best read with:

    data = numpy.load([file_object or file_name])

Each file stores one array, which has dimensions N by 24 by 2.  Each row denotes a point in time (loosely); each column denotes a bit rate.  Each pair of these has both a time (in nanoseconds) and a number of tries; they can be extracted as:

    delay = data[t, rate, 0]
    tries = data[t, rate, 1]
    
Some entries of this array claim to have zero tries that took zero nanoseconds.  These in fact denote missing data; missing data is best detected with:

    if data[t, rate].any():
        ...
